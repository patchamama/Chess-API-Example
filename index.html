<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Advanced Chess Game</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css"
    />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        padding: 20px;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
        background: white;
        border-radius: 15px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        overflow: hidden;
      }

      .header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 20px 30px;
        text-align: center;
      }

      .header h1 {
        font-size: 2.5em;
        margin-bottom: 10px;
      }

      .main-content {
        display: grid;
        grid-template-columns: 600px 1fr;
        gap: 30px;
        padding: 30px;
      }

      .board-section {
        display: flex;
        flex-direction: column;
        gap: 20px;
      }

      .board-container {
        display: flex;
        gap: 15px;
        align-items: center;
      }

      #board {
        width: 600px;
        height: 600px;
      }

      /* Highlight last move */
      .square-55d63 {
        position: relative;
      }

      .highlight-last-move {
        box-shadow: inset 0 0 0 3px rgba(255, 255, 0, 0.6) !important;
      }

      .highlight-last-move::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(255, 255, 0, 0.15);
        pointer-events: none;
      }

      .eval-bar-container {
        width: 40px;
        height: 600px;
        background: #2d3748;
        border-radius: 10px;
        position: relative;
        overflow: hidden;
        box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.3);
      }

      .eval-bar-white {
        position: absolute;
        bottom: 0;
        width: 100%;
        background: linear-gradient(to top, #f7fafc, #e2e8f0);
        transition: height 0.5s ease;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .eval-bar-black {
        position: absolute;
        top: 0;
        width: 100%;
        background: linear-gradient(to bottom, #1a202c, #2d3748);
        transition: height 0.5s ease;
      }

      .eval-text {
        position: absolute;
        width: 100%;
        text-align: center;
        font-weight: bold;
        font-size: 11px;
        color: #4a5568;
        z-index: 10;
        text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8);
      }

      .eval-text.top {
        top: 10px;
      }

      .eval-text.bottom {
        bottom: 10px;
      }

      .eval-text.center {
        top: 50%;
        transform: translateY(-50%);
        font-size: 13px;
        font-weight: 800;
      }

      .eval-advantage {
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(255, 255, 255, 0.9);
        padding: 4px 8px;
        border-radius: 5px;
        font-size: 12px;
        font-weight: bold;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        z-index: 11;
      }

      .eval-advantage.white-adv {
        color: #2d3748;
        bottom: 5px;
      }

      .eval-advantage.black-adv {
        color: #f7fafc;
        background: rgba(45, 55, 72, 0.9);
        top: 5px;
      }

      .controls {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }

      .btn {
        padding: 12px 24px;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 600;
        transition: all 0.3s;
        text-transform: uppercase;
      }

      .btn-primary {
        background: #667eea;
        color: white;
      }

      .btn-primary:hover {
        background: #5568d3;
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
      }

      .btn-secondary {
        background: #48bb78;
        color: white;
      }

      .btn-secondary:hover {
        background: #38a169;
      }

      .btn-danger {
        background: #f56565;
        color: white;
      }

      .btn-danger:hover {
        background: #e53e3e;
      }

      .side-panel {
        display: flex;
        flex-direction: column;
        gap: 20px;
      }

      .panel {
        background: #f7fafc;
        border-radius: 10px;
        padding: 20px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
      }

      .panel h3 {
        color: #2d3748;
        margin-bottom: 15px;
        font-size: 1.3em;
        border-bottom: 2px solid #667eea;
        padding-bottom: 10px;
      }

      .setting {
        margin-bottom: 15px;
      }

      .setting label {
        display: block;
        margin-bottom: 5px;
        color: #4a5568;
        font-weight: 600;
      }

      select,
      input[type='range'] {
        width: 100%;
        padding: 8px;
        border: 2px solid #e2e8f0;
        border-radius: 5px;
        font-size: 14px;
      }

      input[type='range'] {
        cursor: pointer;
      }

      .strength-value {
        display: inline-block;
        background: #667eea;
        color: white;
        padding: 4px 12px;
        border-radius: 5px;
        margin-left: 10px;
        font-weight: bold;
      }

      .status {
        padding: 15px;
        background: #edf2f7;
        border-radius: 8px;
        margin-bottom: 15px;
        border-left: 4px solid #667eea;
      }

      .status-turn {
        font-weight: bold;
        color: #2d3748;
      }

      .status-eval {
        color: #4a5568;
        margin-top: 5px;
      }

      #moveHistory {
        max-height: 200px;
        overflow-y: auto;
        background: white;
        padding: 10px;
        border-radius: 5px;
        font-family: 'Courier New', monospace;
        font-size: 13px;
        line-height: 1.8;
      }

      .move-item {
        padding: 4px 8px;
        margin: 2px 0;
        border-radius: 3px;
        background: #f7fafc;
      }

      .move-item:hover {
        background: #e2e8f0;
      }

      .top-moves {
        max-height: 300px;
        overflow-y: auto;
      }

      .move-card {
        background: white;
        padding: 12px;
        border-radius: 8px;
        margin-bottom: 10px;
        border-left: 4px solid #667eea;
        transition: all 0.2s;
      }

      .move-card:hover {
        transform: translateX(5px);
        box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
      }

      .move-card.best {
        border-left-color: #48bb78;
        background: #f0fff4;
      }

      .move-card.capture {
        border-left-color: #f56565;
      }

      .move-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 5px;
      }

      .move-notation {
        font-weight: bold;
        font-size: 16px;
        color: #2d3748;
      }

      .move-eval {
        font-weight: bold;
        padding: 4px 8px;
        border-radius: 5px;
        font-size: 14px;
      }

      .eval-positive {
        background: #c6f6d5;
        color: #22543d;
      }

      .eval-negative {
        background: #fed7d7;
        color: #742a2a;
      }

      .eval-neutral {
        background: #e2e8f0;
        color: #2d3748;
      }

      .move-details {
        font-size: 12px;
        color: #718096;
      }

      .badge {
        display: inline-block;
        padding: 2px 8px;
        border-radius: 3px;
        font-size: 11px;
        margin-right: 5px;
        font-weight: 600;
      }

      .badge-mate {
        background: #fbd38d;
        color: #744210;
      }

      .badge-capture {
        background: #fc8181;
        color: #742a2a;
      }

      .loading {
        display: none;
        text-align: center;
        padding: 20px;
        color: #667eea;
      }

      .loading.active {
        display: block;
      }

      .spinner {
        border: 3px solid #f3f3f3;
        border-top: 3px solid #667eea;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        animation: spin 1s linear infinite;
        margin: 0 auto 10px;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .captures-section {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
      }

      .capture-item {
        background: white;
        padding: 8px;
        border-radius: 5px;
        font-size: 12px;
      }

      @media (max-width: 1200px) {
        .main-content {
          grid-template-columns: 1fr;
        }

        .board-container {
          justify-content: center;
        }

        .eval-bar-container {
          height: 500px;
        }

        #board {
          width: 500px;
          height: 500px;
        }
      }

      @media (max-width: 768px) {
        .board-container {
          flex-direction: column;
          align-items: center;
        }

        .eval-bar-container {
          width: 90%;
          max-width: 400px;
          height: 30px;
          order: 2;
        }

        .eval-bar-white {
          bottom: auto;
          left: 0;
          width: 50%;
          height: 100%;
        }

        .eval-bar-black {
          top: auto;
          right: 0;
          width: 50%;
          height: 100%;
        }

        .eval-text.top {
          left: 10px;
          top: 50%;
          transform: translateY(-50%);
        }

        .eval-text.bottom {
          right: 10px;
          left: auto;
          top: 50%;
          transform: translateY(-50%);
        }

        .eval-text.center {
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
        }

        #board {
          width: 90%;
          max-width: 400px;
          height: auto;
          aspect-ratio: 1;
          order: 1;
        }
      }

      @media (max-width: 480px) {
        .header h1 {
          font-size: 1.8em;
        }

        .controls {
          flex-direction: column;
        }

        .btn {
          width: 100%;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>‚ôüÔ∏è Advanced Chess Game</h1>
        <p>Play against Stockfish, Lichess, or Chess.com engines</p>
      </div>

      <div class="main-content">
        <!-- Board Section -->
        <div class="board-section">
          <div class="board-container">
            <!-- Evaluation Bar -->
            <div class="eval-bar-container">
              <div class="eval-bar-black" id="evalBarBlack"></div>
              <div class="eval-bar-white" id="evalBarWhite"></div>
              <div class="eval-text top">‚ôö</div>
              <div class="eval-text bottom">‚ôî</div>
              <div class="eval-text center" id="evalBarText">0.0</div>
            </div>

            <!-- Chess Board -->
            <div id="board"></div>
          </div>

          <div class="controls">
            <button class="btn btn-primary" onclick="newGame()">
              New Game
            </button>
            <button class="btn btn-secondary" onclick="analyzePosition()">
              Analyze Position
            </button>
            <button class="btn btn-secondary" onclick="showCapturesOnly()">
              Show Captures
            </button>
            <button class="btn btn-danger" onclick="compareEngines()">
              Compare Engines
            </button>
          </div>

          <div class="panel">
            <h3>üìú Move History</h3>
            <div id="moveHistory"></div>
          </div>
        </div>

        <!-- Side Panel -->
        <div class="side-panel">
          <!-- Settings -->
          <div class="panel">
            <h3>‚öôÔ∏è Game Settings</h3>

            <div class="setting">
              <label>Player Color:</label>
              <select id="playerColor">
                <option value="white" selected>White</option>
                <option value="black">Black</option>
              </select>
            </div>

            <div class="setting">
              <label>Engine:</label>
              <select id="engineType" onchange="changeEngine()">
                <option value="stockfish-backend" selected>
                  Stockfish (Backend)
                </option>
                <option value="stockfish-js">
                  Stockfish.js (Local Browser)
                </option>
                <option value="lichess">Lichess API</option>
                <option value="chesscom">Chess.com API</option>
              </select>
            </div>

            <div class="setting">
              <label>
                Engine Strength:
                <span class="strength-value" id="strengthValue">20</span>
              </label>
              <input
                type="range"
                id="engineStrength"
                min="1"
                max="20"
                value="20"
                oninput="updateStrength(this.value)"
              />
              <small style="color: #718096">1 = Beginner, 20 = Master</small>
            </div>

            <div class="setting">
              <label>Analysis Depth:</label>
              <input
                type="range"
                id="analysisDepth"
                min="10"
                max="30"
                value="20"
              />
              <small style="color: #718096">Higher = Stronger but slower</small>
            </div>
          </div>

          <!-- Status -->
          <div class="panel">
            <h3>üìä Game Status</h3>
            <div class="status">
              <div class="status-turn" id="turnStatus">White to move</div>
              <div class="status-eval" id="evalStatus">Position: Equal</div>
            </div>
          </div>

          <!-- Top Moves -->
          <div class="panel">
            <h3>üéØ Top Moves</h3>
            <div class="loading" id="analysisLoading">
              <div class="spinner"></div>
              <div>Analyzing position...</div>
            </div>
            <div id="topMoves"></div>
          </div>

          <!-- Capture Moves -->
          <div class="panel">
            <h3>‚öîÔ∏è Capture Moves</h3>
            <div id="captureMoves">No captures available</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Scripts -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>

    <script>
      // No pre-loading, we'll create Web Workers directly when needed
      window.stockfishLoaded = true
      window.stockfishLoadPromise = Promise.resolve()
    </script>

    <script>
      // Configuration - Load from config.js or use default
      let API_URL = 'http://127.0.0.1:5000' // Default fallback

      // Try to load configuration from external file
      ;(async function loadConfig() {
        try {
          const response = await fetch('config.json')
          if (response.ok) {
            const config = await response.json()
            if (config.backend_url) {
              API_URL = config.backend_url
              console.log('Loaded backend URL from config.json:', API_URL)
            }
          }
        } catch (error) {
          console.log(
            'No config.json found, using default backend URL:',
            API_URL
          )
        }
      })()

      const GAME_ID = 'web-game-' + Date.now()

      // Game state
      let game = new Chess()
      let board = null
      let playerColor = 'white'
      let currentEngine = 'stockfish-backend'
      let engineStrength = 20
      let isPlayerTurn = true
      let stockfishEngine = null
      let stockfishEngineGame = null // Separate Stockfish instance for playing
      let currentEvaluation = 0
      let lastMove = null // Track last move for highlighting
      let isWaitingForEngine = false

      // Initialize Stockfish.js for local evaluation using Blob approach
      async function initStockfish() {
        console.log('üöÄ Initializing Stockfish using Blob Worker approach...')

        try {
          // Fetch the Stockfish script and create a Blob URL
          const stockfishCDN =
            'https://cdnjs.cloudflare.com/ajax/libs/stockfish.js/10.0.2/stockfish.js'

          console.log('üì• Fetching Stockfish.js from CDN...')
          const response = await fetch(stockfishCDN)

          if (!response.ok) {
            throw new Error(`Failed to fetch Stockfish: ${response.status}`)
          }

          const stockfishCode = await response.text()
          console.log('‚úÖ Stockfish.js downloaded successfully')

          // Create a Blob from the code
          const blob = new Blob([stockfishCode], {
            type: 'application/javascript',
          })
          const blobURL = URL.createObjectURL(blob)

          console.log('üì¶ Created Blob URL for Stockfish')

          // Evaluation engine
          console.log('Creating evaluation engine worker...')
          stockfishEngine = new Worker(blobURL)

          stockfishEngine.onmessage = function (event) {
            const line = event.data

            if (typeof line === 'string') {
              // Parse evaluation from Stockfish output
              if (line.includes('score cp')) {
                const match = line.match(/score cp (-?\d+)/)
                if (match) {
                  let centipawns = parseInt(match[1])
                  const currentTurn = game.turn() // 'w' or 'b'

                  // Stockfish returns evaluation from perspective of side to move
                  // We need to convert to always be from White's perspective
                  // If it's black's turn, invert the score
                  if (currentTurn === 'b') {
                    centipawns = -centipawns
                  }

                  console.log(
                    `Eval: raw=${match[1]}, turn=${currentTurn}, converted=${centipawns}`
                  )
                  updateEvaluationBar(centipawns / 100)
                }
              } else if (line.includes('score mate')) {
                const match = line.match(/score mate (-?\d+)/)
                if (match) {
                  let mateIn = parseInt(match[1])
                  const currentTurn = game.turn()

                  // Invert mate score for black's turn
                  if (currentTurn === 'b') {
                    mateIn = -mateIn
                  }

                  console.log(
                    `Mate: raw=${match[1]}, turn=${currentTurn}, converted=${mateIn}`
                  )
                  updateEvaluationBar(mateIn > 0 ? 100 : -100, true, mateIn)
                }
              }
            }
          }

          stockfishEngine.onerror = function (error) {
            console.error('Evaluation engine error:', error)
          }

          // Initialize UCI protocol
          stockfishEngine.postMessage('uci')

          // Game playing engine (separate worker)
          console.log('Creating game engine worker...')
          stockfishEngineGame = new Worker(blobURL)

          stockfishEngineGame.onmessage = function (event) {
            const line = event.data

            if (typeof line === 'string') {
              // Extract best move
              if (line.includes('bestmove')) {
                const match = line.match(
                  /bestmove ([a-h][1-8][a-h][1-8][qrbn]?)/
                )
                if (match && isWaitingForEngine) {
                  isWaitingForEngine = false
                  const moveUci = match[1]
                  console.log('üéØ Engine suggests:', moveUci)
                  executeStockfishJSMove(moveUci)
                }
              }
            }
          }

          stockfishEngineGame.onerror = function (error) {
            console.error('Game engine error:', error)
            if (isWaitingForEngine) {
              isWaitingForEngine = false
              alert('Engine error. Please try again.')
              updateStatus()
            }
          }

          // Initialize UCI protocol
          stockfishEngineGame.postMessage('uci')

          // Wait a bit for UCI initialization
          await new Promise((resolve) => setTimeout(resolve, 500))

          console.log('‚úÖ Stockfish Web Workers initialized successfully!')
          return true
        } catch (error) {
          console.error('‚ùå Error creating Stockfish Web Workers:', error)
          stockfishEngine = null
          stockfishEngineGame = null

          // Try alternative CDN
          if (error.message && !error.message.includes('unpkg')) {
            console.log('üîÑ Trying alternative CDN...')
            return await initStockfishAlternative()
          }

          return false
        }
      }

      // Alternative initialization with different CDN
      async function initStockfishAlternative() {
        try {
          const altCDN = 'https://unpkg.com/stockfish.js@10.0.2/stockfish.js'

          console.log('üì• Fetching from alternative CDN...')
          const response = await fetch(altCDN)

          if (!response.ok) {
            throw new Error(
              `Failed to fetch from alternative: ${response.status}`
            )
          }

          const stockfishCode = await response.text()
          const blob = new Blob([stockfishCode], {
            type: 'application/javascript',
          })
          const blobURL = URL.createObjectURL(blob)

          // Create workers
          stockfishEngine = new Worker(blobURL)
          stockfishEngine.onmessage = function (event) {
            const line = event.data
            if (typeof line === 'string' && line.includes('score cp')) {
              const match = line.match(/score cp (-?\d+)/)
              if (match) {
                let centipawns = parseInt(match[1])
                const currentTurn = game.turn()

                // Convert to White's perspective
                if (currentTurn === 'b') {
                  centipawns = -centipawns
                }

                console.log(
                  `Eval (alt): raw=${match[1]}, turn=${currentTurn}, converted=${centipawns}`
                )
                updateEvaluationBar(centipawns / 100)
              }
            } else if (line.includes('score mate')) {
              const match = line.match(/score mate (-?\d+)/)
              if (match) {
                let mateIn = parseInt(match[1])
                const currentTurn = game.turn()

                // Invert mate score for black's turn
                if (currentTurn === 'b') {
                  mateIn = -mateIn
                }

                console.log(
                  `Mate (alt): raw=${match[1]}, turn=${currentTurn}, converted=${mateIn}`
                )
                updateEvaluationBar(mateIn > 0 ? 100 : -100, true, mateIn)
              }
            }
          }
          stockfishEngine.postMessage('uci')

          stockfishEngineGame = new Worker(blobURL)
          stockfishEngineGame.onmessage = function (event) {
            const line = event.data
            if (typeof line === 'string' && line.includes('bestmove')) {
              const match = line.match(/bestmove ([a-h][1-8][a-h][1-8][qrbn]?)/)
              if (match && isWaitingForEngine) {
                isWaitingForEngine = false
                executeStockfishJSMove(match[1])
              }
            }
          }
          stockfishEngineGame.postMessage('uci')

          console.log('‚úÖ Alternative CDN worked!')
          return true
        } catch (error) {
          console.error('‚ùå Alternative CDN also failed:', error)
          return false
        }
      }

      // Get move from Stockfish.js
      function getStockfishJSMove() {
        if (!stockfishEngineGame) {
          console.error('Stockfish engine not initialized')
          alert(
            'Stockfish.js engine is not available. Please select a different engine.'
          )
          return
        }

        isWaitingForEngine = true

        // Show thinking indicator
        const statusEl = document.getElementById('turnStatus')
        const originalStatus = statusEl.textContent
        statusEl.textContent = 'ü§î AI is thinking...'
        statusEl.style.color = '#667eea'

        const skillLevel = Math.floor((engineStrength / 20) * 20) // 0-20

        // Send commands to Stockfish
        stockfishEngineGame.postMessage('ucinewgame')
        stockfishEngineGame.postMessage('isready')
        stockfishEngineGame.postMessage(
          'setoption name Skill Level value ' + skillLevel
        )
        stockfishEngineGame.postMessage('position fen ' + game.fen())
        stockfishEngineGame.postMessage('go depth 15')

        console.log(
          'Requested move from Stockfish.js at skill level ' + skillLevel
        )

        // Timeout fallback
        setTimeout(() => {
          if (isWaitingForEngine) {
            isWaitingForEngine = false
            statusEl.textContent = originalStatus
            statusEl.style.color = ''
            alert(
              'Engine timeout. Please try again or select a different engine.'
            )
          }
        }, 30000) // 30 second timeout
      }

      // Execute Stockfish.js move
      function executeStockfishJSMove(moveUci) {
        console.log('Executing Stockfish.js move:', moveUci)

        // Clear thinking indicator
        const statusEl = document.getElementById('turnStatus')
        statusEl.style.color = ''

        const from = moveUci.substring(0, 2)
        const to = moveUci.substring(2, 4)
        const promotion = moveUci.length > 4 ? moveUci.substring(4) : undefined

        const moveObj = {
          from: from,
          to: to,
        }

        if (promotion) {
          moveObj.promotion = promotion
        }

        const result = game.move(moveObj)

        if (result) {
          // Update board position first
          board.position(game.fen())

          // Then update lastMove
          lastMove = { from: from, to: to }

          // Use setTimeout to ensure DOM is updated before highlighting
          setTimeout(() => {
            highlightLastMove()
          }, 50)

          addMoveToHistory(moveUci, 'AI')
          updateStatus()
          saveGameState()

          // Evaluate position after AI move
          setTimeout(() => evaluatePosition(), 100)
        } else {
          console.error('Failed to execute move:', moveUci)
          alert('Invalid move from engine. Please try again.')
          updateStatus()
        }
      }

      // Highlight last move on board
      function highlightLastMove() {
        // Remove previous highlights
        $('#board .square-55d63').removeClass('highlight-last-move')

        if (lastMove) {
          // Add highlight to last move squares
          const fromSquare = '.square-' + lastMove.from
          const toSquare = '.square-' + lastMove.to

          $(fromSquare).addClass('highlight-last-move')
          $(toSquare).addClass('highlight-last-move')
        }
      }

      // Save game state to localStorage
      function saveGameState() {
        const gameState = {
          fen: game.fen(),
          pgn: game.pgn(),
          playerColor: playerColor,
          currentEngine: currentEngine,
          engineStrength: engineStrength,
          lastMove: lastMove,
          moveHistory: game.history({ verbose: true }),
        }

        localStorage.setItem('chessGameState', JSON.stringify(gameState))
      }

      // Load game state from localStorage
      function loadGameState() {
        const savedState = localStorage.getItem('chessGameState')

        if (savedState) {
          try {
            const gameState = JSON.parse(savedState)

            // Restore game
            game.load(gameState.fen)
            board.position(gameState.fen)

            // Restore settings
            playerColor = gameState.playerColor
            currentEngine = gameState.currentEngine
            engineStrength = gameState.engineStrength
            lastMove = gameState.lastMove

            // Update UI
            document.getElementById('playerColor').value = playerColor
            document.getElementById('engineType').value = currentEngine
            document.getElementById('engineStrength').value = engineStrength
            document.getElementById('strengthValue').textContent =
              engineStrength

            if (playerColor === 'black') {
              board.orientation('black')
            } else {
              board.orientation('white')
            }

            // Restore move history
            const historyContainer = document.getElementById('moveHistory')
            historyContainer.innerHTML = ''

            const moves = gameState.moveHistory
            for (let i = 0; i < moves.length; i++) {
              const player =
                moves[i].color === 'w'
                  ? playerColor === 'white'
                    ? 'You'
                    : 'AI'
                  : playerColor === 'white'
                  ? 'AI'
                  : 'You'
              addMoveToHistory(moves[i].from + moves[i].to, player)
            }

            highlightLastMove()
            updateStatus()
            evaluatePosition()

            // Check if it's the engine's turn
            console.log('üîÑ Game loaded from localStorage')
            console.log(
              'Current turn:',
              game.turn() === 'w' ? 'White' : 'Black'
            )
            console.log('Player color:', playerColor)
            console.log('Current engine:', currentEngine)

            if (!game.game_over()) {
              const currentTurn = game.turn() // 'w' or 'b'
              const isWhiteTurn = currentTurn === 'w'
              const isPlayerWhite = playerColor === 'white'

              // Determine if it's the engine's turn
              const isEngineTurn =
                (isWhiteTurn && !isPlayerWhite) ||
                (!isWhiteTurn && isPlayerWhite)

              if (isEngineTurn) {
                console.log("ü§ñ It's the engine's turn, requesting move...")

                // Wait a bit for UI to be ready
                setTimeout(() => {
                  if (currentEngine === 'stockfish-js') {
                    // Use local Stockfish.js
                    if (stockfishEngineGame) {
                      getStockfishJSMove()
                    } else {
                      console.warn('‚ö†Ô∏è Stockfish.js not ready, initializing...')
                      initStockfish().then((success) => {
                        if (success && stockfishEngineGame) {
                          getStockfishJSMove()
                        } else {
                          console.error(
                            '‚ùå Failed to initialize Stockfish.js for engine turn'
                          )
                        }
                      })
                    }
                  } else {
                    // Use backend engine
                    // We need to get the AI move from backend
                    console.log('üì° Requesting move from backend engine...')
                    requestBackendMove()
                  }
                }, 1000)
              } else {
                console.log("üë§ It's the player's turn")
              }
            } else {
              console.log('üèÅ Game is over')
            }

            return true
          } catch (error) {
            console.error('Error loading game state:', error)
            return false
          }
        }

        return false
      }

      // Request move from backend engine (for game restore)
      async function requestBackendMove() {
        try {
          const response = await fetch(`${API_URL}/analyze_position`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              game_id: GAME_ID,
              fen: game.fen(), // Enviar FEN actual
              engine:
                currentEngine === 'stockfish-backend'
                  ? 'stockfish'
                  : currentEngine,
              top_moves: 1,
              depth: 20,
            }),
          })

          const data = await response.json()

          if (data.error) {
            console.error('Backend error:', data.error)
            console.warn(
              '‚ö†Ô∏è Could not get engine move after reload:',
              data.error
            )
            return
          }

          if (data.best_move) {
            console.log('‚úÖ Backend suggested move:', data.best_move)

            // Parse and execute the move
            const from = data.best_move.substring(0, 2)
            const to = data.best_move.substring(2, 4)
            const promotion =
              data.best_move.length > 4
                ? data.best_move.substring(4)
                : undefined

            const moveObj = { from, to }
            if (promotion) moveObj.promotion = promotion

            const result = game.move(moveObj)

            if (result) {
              board.position(game.fen())
              lastMove = { from, to }

              setTimeout(() => {
                highlightLastMove()
              }, 50)

              addMoveToHistory(data.best_move, 'AI')
              updateStatus()
              saveGameState()

              // Evaluate position after AI move
              setTimeout(() => evaluatePosition(), 100)
            }
          }
        } catch (error) {
          console.error('‚ùå Error requesting backend move:', error)
          console.warn(
            '‚ö†Ô∏è Could not get engine move after reload. Please make a move or start a new game.'
          )
        }
      }

      // Clear saved game state
      function clearGameState() {
        localStorage.removeItem('chessGameState')
      }

      // Evaluate position with local Stockfish
      function evaluatePosition() {
        if (!stockfishEngine) {
          console.log('Stockfish engine not available for evaluation')
          return
        }

        try {
          stockfishEngine.postMessage('ucinewgame')
          stockfishEngine.postMessage('isready')
          stockfishEngine.postMessage('position fen ' + game.fen())
          stockfishEngine.postMessage('go depth 15')
        } catch (error) {
          console.error('Error evaluating position:', error)
        }
      }

      // Update evaluation bar
      // NOTE: evaluation parameter should ALWAYS be from White's perspective
      // Positive = White advantage, Negative = Black advantage
      function updateEvaluationBar(evaluation, isMate = false, mateIn = null) {
        currentEvaluation = evaluation

        const evalBarWhite = document.getElementById('evalBarWhite')
        const evalBarBlack = document.getElementById('evalBarBlack')
        const evalBarText = document.getElementById('evalBarText')

        // Clamp evaluation between -10 and +10 for display
        let displayEval = Math.max(-10, Math.min(10, evaluation))

        // Calculate percentage (50% = equal, 0% = black winning, 100% = white winning)
        // Formula: 50 + (eval * 5) to map -10..+10 to 0..100
        let whitePercentage = 50 + displayEval * 5
        whitePercentage = Math.max(0, Math.min(100, whitePercentage))

        const blackPercentage = 100 - whitePercentage

        // Update bar heights
        evalBarWhite.style.height = whitePercentage + '%'
        evalBarBlack.style.height = blackPercentage + '%'

        // Update text
        if (isMate && mateIn !== null) {
          evalBarText.textContent = `M${Math.abs(mateIn)}`
          evalBarText.style.color = mateIn > 0 ? '#2d3748' : '#f7fafc'
        } else {
          const evalText =
            evaluation >= 0
              ? `+${evaluation.toFixed(1)}`
              : evaluation.toFixed(1)
          evalBarText.textContent = evalText

          // Position text in the larger section
          if (whitePercentage > 60) {
            evalBarText.style.color = '#2d3748'
            evalBarText.style.top = 'auto'
            evalBarText.style.bottom = whitePercentage / 2 + '%'
            evalBarText.style.transform = 'translateY(50%)'
          } else if (blackPercentage > 60) {
            evalBarText.style.color = '#f7fafc'
            evalBarText.style.top = blackPercentage / 2 + '%'
            evalBarText.style.bottom = 'auto'
            evalBarText.style.transform = 'translateY(-50%)'
          } else {
            evalBarText.style.color = evaluation >= 0 ? '#2d3748' : '#f7fafc'
            evalBarText.style.top = '50%'
            evalBarText.style.bottom = 'auto'
            evalBarText.style.transform = 'translateY(-50%)'
          }
        }
      }

      // Initialize board
      function initBoard() {
        const config = {
          draggable: true,
          position: 'start',
          onDragStart: onDragStart,
          onDrop: onDrop,
          onSnapEnd: onSnapEnd,
        }

        board = Chessboard('board', config)
        $(window).resize(board.resize)
      }

      // Drag start handler
      function onDragStart(source, piece, position, orientation) {
        // Don't allow moves if game is over
        if (game.game_over()) return false

        // Only allow player to move their pieces
        if (
          (game.turn() === 'w' && piece.search(/^b/) !== -1) ||
          (game.turn() === 'b' && piece.search(/^w/) !== -1)
        ) {
          return false
        }

        // Only allow moves on player's turn
        if (
          (playerColor === 'white' && game.turn() !== 'w') ||
          (playerColor === 'black' && game.turn() !== 'b')
        ) {
          return false
        }
      }

      // Drop handler
      function onDrop(source, target) {
        // Save FEN BEFORE the move
        const fenBeforeMove = game.fen()

        // Check if move is legal
        const move = game.move({
          from: source,
          to: target,
          promotion: 'q', // Always promote to queen for simplicity
        })

        // Illegal move
        if (move === null) return 'snapback'

        // Save last move for highlighting
        lastMove = { from: source, to: target }

        // Highlight immediately after player's move
        setTimeout(() => {
          highlightLastMove()
        }, 50)

        // Evaluate position after player move
        setTimeout(() => evaluatePosition(), 100)

        // Save game state
        saveGameState()

        // Make move on server or use Stockfish.js
        if (currentEngine === 'stockfish-js') {
          addMoveToHistory(move.from + move.to, 'You')
          updateStatus()

          // Get AI move from Stockfish.js
          setTimeout(() => {
            getStockfishJSMove()
          }, 500)
        } else {
          // Send FEN BEFORE the player's move
          makeMove(move.from + move.to, fenBeforeMove)
        }
      }

      // Snap end handler
      function onSnapEnd() {
        board.position(game.fen())
      }

      // Update strength display
      function updateStrength(value) {
        engineStrength = parseInt(value)
        document.getElementById('strengthValue').textContent = value

        // Update on server
        fetch(`${API_URL}/set_engine_strength`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            game_id: GAME_ID,
            strength: engineStrength,
          }),
        })
      }

      // Change engine during game
      async function changeEngine() {
        const newEngine = document.getElementById('engineType').value
        const oldEngine = currentEngine

        console.log(`üîÑ Changing engine from ${oldEngine} to ${newEngine}`)

        // Update current engine
        currentEngine = newEngine

        // If switching to Stockfish.js, make sure it's initialized
        if (newEngine === 'stockfish-js') {
          if (!stockfishEngineGame) {
            console.log('Stockfish.js not initialized, initializing now...')

            const statusEl = document.getElementById('turnStatus')
            const originalStatus = statusEl.textContent
            statusEl.textContent = '‚è≥ Loading Stockfish.js engine...'
            statusEl.style.color = '#667eea'

            const success = await initStockfish()

            if (success && stockfishEngineGame) {
              statusEl.textContent = originalStatus
              statusEl.style.color = ''
              console.log('‚úÖ Stockfish.js ready, engine changed successfully')

              // Show notification
              showNotification(
                '‚úÖ Engine changed to Stockfish.js (Local Browser)'
              )
            } else {
              statusEl.textContent = originalStatus
              statusEl.style.color = ''
              alert(
                'Failed to initialize Stockfish.js. Reverting to previous engine.'
              )

              // Revert to old engine
              currentEngine = oldEngine
              document.getElementById('engineType').value = oldEngine
              return
            }
          } else {
            console.log('‚úÖ Stockfish.js already initialized')
            showNotification(
              '‚úÖ Engine changed to Stockfish.js (Local Browser)'
            )
          }
        } else {
          // Backend engine
          const engineNames = {
            'stockfish-backend': 'Stockfish (Backend)',
            lichess: 'Lichess API',
            chesscom: 'Chess.com API',
          }

          showNotification(
            `‚úÖ Engine changed to ${engineNames[newEngine] || newEngine}`
          )
          console.log(`‚úÖ Engine changed to ${newEngine}`)
          console.log('‚ÑπÔ∏è Backend will use this engine on next move')
        }

        // Save the change
        saveGameState()
      }

      // Show notification helper
      function showNotification(message) {
        const notification = document.createElement('div')
        notification.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: #48bb78;
          color: white;
          padding: 15px 20px;
          border-radius: 8px;
          box-shadow: 0 4px 12px rgba(0,0,0,0.15);
          z-index: 10000;
          font-weight: 600;
          animation: slideIn 0.3s ease;
        `
        notification.textContent = message

        // Add animation
        const style = document.createElement('style')
        style.textContent = `
          @keyframes slideIn {
            from {
              transform: translateX(400px);
              opacity: 0;
            }
            to {
              transform: translateX(0);
              opacity: 1;
            }
          }
          @keyframes slideOut {
            from {
              transform: translateX(0);
              opacity: 1;
            }
            to {
              transform: translateX(400px);
              opacity: 0;
            }
          }
        `

        if (!document.querySelector('#notification-styles')) {
          style.id = 'notification-styles'
          document.head.appendChild(style)
        }

        document.body.appendChild(notification)

        // Remove after 3 seconds
        setTimeout(() => {
          notification.style.animation = 'slideOut 0.3s ease'
          setTimeout(() => {
            document.body.removeChild(notification)
          }, 300)
        }, 3000)
      }

      // New game
      async function newGame() {
        playerColor = document.getElementById('playerColor').value
        currentEngine = document.getElementById('engineType').value
        engineStrength = parseInt(
          document.getElementById('engineStrength').value
        )

        game.reset()
        board.position('start')

        if (playerColor === 'black') {
          board.orientation('black')
        } else {
          board.orientation('white')
        }

        document.getElementById('moveHistory').innerHTML = ''
        document.getElementById('topMoves').innerHTML = ''
        document.getElementById('captureMoves').innerHTML =
          'No captures available'

        // Reset evaluation bar
        updateEvaluationBar(0)

        // Clear last move highlight
        lastMove = null
        highlightLastMove()

        // Clear saved state for new game
        clearGameState()

        // If using Stockfish.js, don't need backend
        if (currentEngine === 'stockfish-js') {
          // Check if Stockfish is available, if not try to initialize it
          if (!stockfishEngineGame) {
            console.log(
              'Stockfish.js not initialized, attempting to initialize now...'
            )

            // Show loading message
            const statusEl = document.getElementById('turnStatus')
            statusEl.textContent = '‚è≥ Loading Stockfish engine...'
            statusEl.style.color = '#667eea'

            // Try to initialize Stockfish
            initStockfish()
              .then((success) => {
                if (success && stockfishEngineGame) {
                  console.log(
                    'Stockfish.js initialized successfully, starting game...'
                  )
                  statusEl.textContent = ''
                  statusEl.style.color = ''

                  // Now start the game with Stockfish
                  if (playerColor === 'black') {
                    setTimeout(() => {
                      getStockfishJSMove()
                    }, 800)
                  } else {
                    setTimeout(() => evaluatePosition(), 200)
                  }
                  updateStatus()
                  saveGameState()
                } else {
                  // Failed to initialize
                  statusEl.textContent = ''
                  statusEl.style.color = ''
                  alert(
                    'Stockfish.js engine could not be loaded. This may happen because:\n\n' +
                      '1. The CDN is blocked or slow\n' +
                      "2. Your browser doesn't support Web Workers\n" +
                      '3. JavaScript is restricted\n\n' +
                      'Please try:\n' +
                      '‚Ä¢ Refreshing the page\n' +
                      '‚Ä¢ Using a different browser (Chrome/Firefox recommended)\n' +
                      '‚Ä¢ Selecting a backend engine instead'
                  )

                  // Fallback to backend engine
                  document.getElementById('engineType').value =
                    'stockfish-backend'
                  currentEngine = 'stockfish-backend'
                  // Don't return, continue with backend logic below
                }
              })
              .catch((error) => {
                console.error('Failed to initialize Stockfish:', error)
                statusEl.textContent = ''
                statusEl.style.color = ''
                alert(
                  'Error loading Stockfish.js. Switching to backend engine.'
                )
                document.getElementById('engineType').value =
                  'stockfish-backend'
                currentEngine = 'stockfish-backend'
              })

            // If we successfully have the engine, return here
            if (stockfishEngineGame) {
              // Stockfish.js is available
              console.log('Starting new game with Stockfish.js')

              // If player chose black, get AI move
              if (playerColor === 'black') {
                setTimeout(() => {
                  getStockfishJSMove()
                }, 800)
              } else {
                setTimeout(() => evaluatePosition(), 200)
              }
              updateStatus()
              saveGameState()
              return
            } else {
              // Wait for async initialization, return early
              return
            }
          } else {
            // Stockfish.js is already available
            console.log('Starting new game with Stockfish.js')

            // If player chose black, get AI move
            if (playerColor === 'black') {
              setTimeout(() => {
                getStockfishJSMove()
              }, 800)
            } else {
              setTimeout(() => evaluatePosition(), 200)
            }
            updateStatus()
            saveGameState()
            return
          }
        }

        try {
          const response = await fetch(`${API_URL}/new_game`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              game_id: GAME_ID,
              color: playerColor,
              engine_strength: engineStrength,
              engine:
                currentEngine === 'stockfish-backend'
                  ? 'stockfish'
                  : currentEngine, // Enviar motor
            }),
          })

          const data = await response.json()

          if (data.ai_move) {
            setTimeout(() => {
              // Parse the AI move
              const from = data.ai_move.substring(0, 2)
              const to = data.ai_move.substring(2, 4)
              const promotion =
                data.ai_move.length > 4 ? data.ai_move.substring(4) : undefined

              const moveObj = {
                from: from,
                to: to,
              }

              if (promotion) {
                moveObj.promotion = promotion
              }

              const result = game.move(moveObj)

              if (result) {
                board.position(game.fen())

                // Update lastMove and highlight for AI's opening move
                lastMove = { from: from, to: to }
                setTimeout(() => {
                  highlightLastMove()
                }, 50)

                addMoveToHistory(data.ai_move, 'AI')
                updateStatus()

                // Evaluate position after AI move
                setTimeout(() => evaluatePosition(), 100)

                if (data.analysis) {
                  displayAnalysis(data.analysis)
                }
              } else {
                console.error('Failed to make AI move:', data.ai_move)
                // Fallback: sync with server FEN
                game.load(data.fen)
                board.position(data.fen)
                setTimeout(() => evaluatePosition(), 100)
              }
            }, 500)
          }

          updateStatus()
        } catch (error) {
          console.error('Error creating new game:', error)
          alert('Error connecting to server. Make sure the backend is running!')
        }
      }

      // Make move
      async function makeMove(moveUci, fenBeforeMove) {
        // Use provided FEN or current FEN
        const fenToSend = fenBeforeMove || game.fen()

        try {
          const response = await fetch(`${API_URL}/make_move`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              game_id: GAME_ID,
              move: moveUci,
              fen: fenToSend, // Send FEN BEFORE player's move
              engine:
                currentEngine === 'stockfish-backend'
                  ? 'stockfish'
                  : currentEngine,
              engine_strength: engineStrength,
            }),
          })

          const data = await response.json()

          if (data.success) {
            addMoveToHistory(data.player_move, 'You')
            updateStatus()

            if (data.ai_move) {
              setTimeout(() => {
                // Parse the AI move (format: e2e4 or e7e8q for promotions)
                const from = data.ai_move.substring(0, 2)
                const to = data.ai_move.substring(2, 4)
                const promotion =
                  data.ai_move.length > 4
                    ? data.ai_move.substring(4)
                    : undefined

                // Make the move in chess.js
                const moveObj = {
                  from: from,
                  to: to,
                }

                if (promotion) {
                  moveObj.promotion = promotion
                }

                const result = game.move(moveObj)

                if (result) {
                  // Update the board visually
                  board.position(game.fen())

                  // Update lastMove and highlight for AI's move
                  lastMove = { from: from, to: to }
                  setTimeout(() => {
                    highlightLastMove()
                  }, 50)

                  addMoveToHistory(data.ai_move, 'AI')
                  updateStatus()

                  if (data.analysis) {
                    displayAnalysis(data.analysis)
                  }
                } else {
                  console.error('Failed to make AI move:', data.ai_move)
                  // Fallback: sync with server FEN
                  if (data.fen) {
                    game.load(data.fen)
                    board.position(data.fen)
                  }
                }
              }, 500)
            }

            if (data.game_over) {
              setTimeout(() => {
                if (game.in_checkmate()) {
                  alert('Checkmate! Game over.')
                } else if (game.in_draw()) {
                  alert('Draw! Game over.')
                } else if (game.in_stalemate()) {
                  alert('Stalemate! Game over.')
                }
              }, 600)
            }
          } else if (data.error) {
            console.error('Backend error:', data.error)
            alert(`Error: ${data.error}`)

            // Revert the move locally if backend rejected it
            game.undo()
            board.position(game.fen())
          }
        } catch (error) {
          console.error('Error making move:', error)
          alert(
            'Failed to communicate with backend. Using Stockfish.js as fallback.'
          )

          // Revert move
          game.undo()
          board.position(game.fen())

          // Fallback to Stockfish.js
          if (stockfishEngineGame) {
            getStockfishJSMove()
          }
        }
      }

      // Analyze position
      async function analyzePosition() {
        document.getElementById('analysisLoading').classList.add('active')
        document.getElementById('topMoves').innerHTML = ''

        currentEngine = document.getElementById('engineType').value
        const depth = parseInt(document.getElementById('analysisDepth').value)

        // If using Stockfish.js, we can't get detailed analysis easily
        if (currentEngine === 'stockfish-js') {
          document.getElementById('analysisLoading').classList.remove('active')
          alert(
            'Detailed analysis not available with Stockfish.js engine. Please use backend engines for full analysis.'
          )
          return
        }

        try {
          const response = await fetch(`${API_URL}/analyze_position`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              game_id: GAME_ID,
              fen: game.fen(), // Enviar FEN actual
              engine:
                currentEngine === 'stockfish-backend'
                  ? 'stockfish'
                  : currentEngine,
              top_moves: 5,
              depth: depth,
            }),
          })

          const data = await response.json()

          if (data.error) {
            console.error('Analysis error:', data.error)
            alert(`Analysis error: ${data.error}`)
          } else {
            displayAnalysis(data)
          }
        } catch (error) {
          console.error('Error analyzing position:', error)
          alert(
            'Failed to analyze position. Please check if the backend is running.'
          )
        } finally {
          document.getElementById('analysisLoading').classList.remove('active')
        }
      }

      // Display analysis
      function displayAnalysis(analysis) {
        const container = document.getElementById('topMoves')
        container.innerHTML = ''

        if (!analysis.top_moves || analysis.top_moves.length === 0) {
          container.innerHTML = '<p>No analysis available</p>'
          return
        }

        // Update evaluation bar with position evaluation
        if (analysis.position_evaluation !== undefined) {
          updateEvaluationBar(analysis.position_evaluation / 100)
        }

        analysis.top_moves.forEach((move, index) => {
          const moveCard = document.createElement('div')
          moveCard.className =
            'move-card' +
            (index === 0 ? ' best' : '') +
            (move.is_capture ? ' capture' : '')

          const evalClass =
            move.evaluation > 50
              ? 'eval-positive'
              : move.evaluation < -50
              ? 'eval-negative'
              : 'eval-neutral'

          const evalText = move.is_mate
            ? `Mate in ${Math.abs(move.mate_in)}`
            : `${(move.evaluation / 100).toFixed(2)}`

          moveCard.innerHTML = `
                    <div class="move-header">
                        <span class="move-notation">${index + 1}. ${
            move.move
          }</span>
                        <span class="move-eval ${evalClass}">${evalText}</span>
                    </div>
                    <div class="move-details">
                        ${
                          move.is_mate
                            ? '<span class="badge badge-mate">MATE</span>'
                            : ''
                        }
                        ${
                          move.is_capture
                            ? '<span class="badge badge-capture">CAPTURE</span>'
                            : ''
                        }
                        ${move.piece} from ${move.from_square} to ${
            move.to_square
          }
                    </div>
                `

          container.appendChild(moveCard)
        })

        // Display captures
        if (analysis.capture_moves && analysis.capture_moves.length > 0) {
          displayCaptures(analysis.capture_moves)
        }

        // Update evaluation
        updateEvaluation(analysis.position_evaluation)
      }

      // Show captures only
      async function showCapturesOnly() {
        currentEngine = document.getElementById('engineType').value

        try {
          // Encode FEN for URL
          const encodedFen = encodeURIComponent(game.fen())
          const engineParam =
            currentEngine === 'stockfish-backend' ? 'stockfish' : currentEngine

          const response = await fetch(
            `${API_URL}/get_capture_moves?game_id=${GAME_ID}&engine=${engineParam}&fen=${encodedFen}`
          )

          const data = await response.json()

          if (data.error) {
            console.error('Captures error:', data.error)
            alert(`Error: ${data.error}`)
          } else if (data.capture_moves) {
            displayCaptures(data.capture_moves)
          }
        } catch (error) {
          console.error('Error getting captures:', error)
          alert(
            'Failed to get capture moves. Please check if the backend is running.'
          )
        }
      }

      // Display captures
      function displayCaptures(captures) {
        const container = document.getElementById('captureMoves')

        if (captures.length === 0) {
          container.innerHTML = 'No captures available'
          return
        }

        container.innerHTML = '<div class="captures-section"></div>'
        const section = container.querySelector('.captures-section')

        captures.forEach((move) => {
          const captureItem = document.createElement('div')
          captureItem.className = 'capture-item'

          const evalText = move.is_mate
            ? `M${Math.abs(move.mate_in)}`
            : `${(move.evaluation / 100).toFixed(1)}`

          captureItem.innerHTML = `
                    <strong>${move.move}</strong><br>
                    ${move.piece}: ${move.from_square}‚Üí${move.to_square}<br>
                    Eval: ${evalText}
                `

          section.appendChild(captureItem)
        })
      }

      // Compare engines
      async function compareEngines() {
        if (
          !confirm('This will analyze the position with all engines. Continue?')
        ) {
          return
        }

        document.getElementById('analysisLoading').classList.add('active')

        try {
          const response = await fetch(`${API_URL}/compare_engines`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              game_id: GAME_ID,
              fen: game.fen(), // Enviar FEN actual
            }),
          })

          const data = await response.json()

          if (data.error) {
            console.error('Comparison error:', data.error)
            alert(`Error: ${data.error}`)
          } else {
            let comparisonHTML = '<h4>Engine Comparison:</h4>'

            for (const [engine, analysis] of Object.entries(data)) {
              comparisonHTML += `
                          <div class="move-card">
                              <strong>${engine.toUpperCase()}</strong><br>
                              Best: ${analysis.best_move} 
                              (${(analysis.evaluation / 100).toFixed(2)})<br>
                              <small>Top 3: ${analysis.top_3
                                .map((m) => m.move)
                                .join(', ')}</small>
                          </div>
                      `
            }

            document.getElementById('topMoves').innerHTML = comparisonHTML
          }
        } catch (error) {
          console.error('Error comparing engines:', error)
          alert(
            'Failed to compare engines. Please check if the backend is running.'
          )
        } finally {
          document.getElementById('analysisLoading').classList.remove('active')
        }
      }

      // Add move to history
      function addMoveToHistory(move, player) {
        const history = document.getElementById('moveHistory')
        const moveItem = document.createElement('div')
        moveItem.className = 'move-item'

        const moveNumber = Math.floor(game.history().length / 2) + 1
        moveItem.textContent = `${moveNumber}. ${player}: ${move}`

        history.appendChild(moveItem)
        history.scrollTop = history.scrollHeight
      }

      // Update status
      function updateStatus() {
        const turn = game.turn() === 'w' ? 'White' : 'Black'
        const status = document.getElementById('turnStatus')

        if (game.in_checkmate()) {
          status.textContent =
            'Checkmate! ' + (turn === 'White' ? 'Black' : 'White') + ' wins!'
        } else if (game.in_draw()) {
          status.textContent = 'Draw!'
        } else if (game.in_stalemate()) {
          status.textContent = 'Stalemate!'
        } else {
          status.textContent = turn + ' to move'
          if (game.in_check()) {
            status.textContent += ' (in check)'
          }
        }
      }

      // Update evaluation
      function updateEvaluation(eval) {
        const evalStatus = document.getElementById('evalStatus')
        const evalValue = eval / 100

        if (Math.abs(evalValue) < 0.5) {
          evalStatus.textContent = 'Position: Equal'
        } else if (evalValue > 0) {
          evalStatus.textContent = `Position: White is better (+${evalValue.toFixed(
            2
          )})`
        } else {
          evalStatus.textContent = `Position: Black is better (${evalValue.toFixed(
            2
          )})`
        }
      }

      // Initialize on load
      window.onload = async function () {
        initBoard()
        updateStatus()
        updateEvaluationBar(0) // Initialize bar at equal position

        // Try to initialize Stockfish Web Workers
        console.log('üåê Page loaded, initializing Stockfish Web Workers...')

        setTimeout(async () => {
          const success = await initStockfish()

          if (success) {
            console.log('‚úÖ Stockfish.js is ready!')
          } else {
            console.warn(
              '‚ö†Ô∏è Stockfish.js not available - use backend engines instead'
            )
          }
        }, 500)

        // Try to load saved game state
        const loaded = loadGameState()

        // If no saved state, start a new game
        if (!loaded) {
          setTimeout(() => {
            newGame()
          }, 1000)
        }
      }

      // Add error handling for script loading
      window.addEventListener('error', function (e) {
        if (e.filename && e.filename.includes('stockfish')) {
          console.error('Failed to load Stockfish.js:', e.message)
        }
      })
    </script>
  </body>
</html>
