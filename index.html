<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Advanced Chess Game</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css"
    />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        padding: 20px;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
        background: white;
        border-radius: 15px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        overflow: hidden;
      }

      .header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 20px 30px;
        text-align: center;
      }

      .header h1 {
        font-size: 2.5em;
        margin-bottom: 10px;
      }

      .main-content {
        display: grid;
        grid-template-columns: 600px 1fr;
        gap: 30px;
        padding: 30px;
      }

      .board-section {
        display: flex;
        flex-direction: column;
        gap: 20px;
      }

      .board-container {
        display: flex;
        gap: 15px;
        align-items: center;
      }

      #board {
        width: 600px;
        height: 600px;
      }

      /* Highlight last move */
      .square-55d63 {
        position: relative;
      }

      .highlight-last-move {
        box-shadow: inset 0 0 0 3px rgba(255, 255, 0, 0.6) !important;
      }

      .highlight-last-move::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(255, 255, 0, 0.15);
        pointer-events: none;
      }

      .eval-bar-container {
        width: 40px;
        height: 600px;
        background: #2d3748;
        border-radius: 10px;
        position: relative;
        overflow: hidden;
        box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.3);
      }

      .eval-bar-white {
        position: absolute;
        bottom: 0;
        width: 100%;
        background: linear-gradient(to top, #f7fafc, #e2e8f0);
        transition: height 0.5s ease;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .eval-bar-black {
        position: absolute;
        top: 0;
        width: 100%;
        background: linear-gradient(to bottom, #1a202c, #2d3748);
        transition: height 0.5s ease;
      }

      .eval-text {
        position: absolute;
        width: 100%;
        text-align: center;
        font-weight: bold;
        font-size: 11px;
        color: #4a5568;
        z-index: 10;
        text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8);
      }

      .eval-text.top {
        top: 10px;
      }

      .eval-text.bottom {
        bottom: 10px;
      }

      .eval-text.center {
        top: 50%;
        transform: translateY(-50%);
        font-size: 13px;
        font-weight: 800;
      }

      .eval-advantage {
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(255, 255, 255, 0.9);
        padding: 4px 8px;
        border-radius: 5px;
        font-size: 12px;
        font-weight: bold;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        z-index: 11;
      }

      .eval-advantage.white-adv {
        color: #2d3748;
        bottom: 5px;
      }

      .eval-advantage.black-adv {
        color: #f7fafc;
        background: rgba(45, 55, 72, 0.9);
        top: 5px;
      }

      .controls {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }

      .btn {
        padding: 12px 24px;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 600;
        transition: all 0.3s;
        text-transform: uppercase;
      }

      .btn-primary {
        background: #667eea;
        color: white;
      }

      .btn-primary:hover {
        background: #5568d3;
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
      }

      .btn-secondary {
        background: #48bb78;
        color: white;
      }

      .btn-secondary:hover {
        background: #38a169;
      }

      .btn-danger {
        background: #f56565;
        color: white;
      }

      .btn-danger:hover {
        background: #e53e3e;
      }

      .side-panel {
        display: flex;
        flex-direction: column;
        gap: 20px;
      }

      .panel {
        background: #f7fafc;
        border-radius: 10px;
        padding: 20px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
      }

      .panel h3 {
        color: #2d3748;
        margin-bottom: 15px;
        font-size: 1.3em;
        border-bottom: 2px solid #667eea;
        padding-bottom: 10px;
      }

      .setting {
        margin-bottom: 15px;
      }

      .setting label {
        display: block;
        margin-bottom: 5px;
        color: #4a5568;
        font-weight: 600;
      }

      select,
      input[type='range'] {
        width: 100%;
        padding: 8px;
        border: 2px solid #e2e8f0;
        border-radius: 5px;
        font-size: 14px;
      }

      input[type='range'] {
        cursor: pointer;
      }

      .strength-value {
        display: inline-block;
        background: #667eea;
        color: white;
        padding: 4px 12px;
        border-radius: 5px;
        margin-left: 10px;
        font-weight: bold;
      }

      .status {
        padding: 15px;
        background: #edf2f7;
        border-radius: 8px;
        margin-bottom: 15px;
        border-left: 4px solid #667eea;
      }

      .status-turn {
        font-weight: bold;
        color: #2d3748;
      }

      .status-eval {
        color: #4a5568;
        margin-top: 5px;
      }

      #moveHistory {
        max-height: 200px;
        overflow-y: auto;
        background: white;
        padding: 10px;
        border-radius: 5px;
        font-family: 'Courier New', monospace;
        font-size: 13px;
        line-height: 1.8;
      }

      .move-item {
        padding: 4px 8px;
        margin: 2px 0;
        border-radius: 3px;
        background: #f7fafc;
      }

      .move-item:hover {
        background: #e2e8f0;
      }

      .top-moves {
        max-height: 300px;
        overflow-y: auto;
      }

      .move-card {
        background: white;
        padding: 12px;
        border-radius: 8px;
        margin-bottom: 10px;
        border-left: 4px solid #667eea;
        transition: all 0.2s;
      }

      .move-card:hover {
        transform: translateX(5px);
        box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
      }

      .move-card.best {
        border-left-color: #48bb78;
        background: #f0fff4;
      }

      .move-card.capture {
        border-left-color: #f56565;
      }

      .move-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 5px;
      }

      .move-notation {
        font-weight: bold;
        font-size: 16px;
        color: #2d3748;
      }

      .move-eval {
        font-weight: bold;
        padding: 4px 8px;
        border-radius: 5px;
        font-size: 14px;
      }

      .eval-positive {
        background: #c6f6d5;
        color: #22543d;
      }

      .eval-negative {
        background: #fed7d7;
        color: #742a2a;
      }

      .eval-neutral {
        background: #e2e8f0;
        color: #2d3748;
      }

      .move-details {
        font-size: 12px;
        color: #718096;
      }

      .badge {
        display: inline-block;
        padding: 2px 8px;
        border-radius: 3px;
        font-size: 11px;
        margin-right: 5px;
        font-weight: 600;
      }

      .badge-mate {
        background: #fbd38d;
        color: #744210;
      }

      .badge-capture {
        background: #fc8181;
        color: #742a2a;
      }

      .loading {
        display: none;
        text-align: center;
        padding: 20px;
        color: #667eea;
      }

      .loading.active {
        display: block;
      }

      .spinner {
        border: 3px solid #f3f3f3;
        border-top: 3px solid #667eea;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        animation: spin 1s linear infinite;
        margin: 0 auto 10px;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .captures-section {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
      }

      .capture-item {
        background: white;
        padding: 8px;
        border-radius: 5px;
        font-size: 12px;
      }

      @media (max-width: 1200px) {
        .main-content {
          grid-template-columns: 1fr;
        }

        #board {
          width: 100%;
          max-width: 600px;
          margin: 0 auto;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>‚ôüÔ∏è Advanced Chess Game</h1>
        <p>Play against Stockfish, Lichess, or Chess.com engines</p>
      </div>

      <div class="main-content">
        <!-- Board Section -->
        <div class="board-section">
          <div class="board-container">
            <!-- Evaluation Bar -->
            <div class="eval-bar-container">
              <div class="eval-bar-black" id="evalBarBlack"></div>
              <div class="eval-bar-white" id="evalBarWhite"></div>
              <div class="eval-text top">‚ôö</div>
              <div class="eval-text bottom">‚ôî</div>
              <div class="eval-text center" id="evalBarText">0.0</div>
            </div>

            <!-- Chess Board -->
            <div id="board"></div>
          </div>

          <div class="controls">
            <button class="btn btn-primary" onclick="newGame()">
              New Game
            </button>
            <button class="btn btn-secondary" onclick="analyzePosition()">
              Analyze Position
            </button>
            <button class="btn btn-secondary" onclick="showCapturesOnly()">
              Show Captures
            </button>
            <button class="btn btn-danger" onclick="compareEngines()">
              Compare Engines
            </button>
          </div>

          <div class="panel">
            <h3>üìú Move History</h3>
            <div id="moveHistory"></div>
          </div>
        </div>

        <!-- Side Panel -->
        <div class="side-panel">
          <!-- Settings -->
          <div class="panel">
            <h3>‚öôÔ∏è Game Settings</h3>

            <div class="setting">
              <label>Player Color:</label>
              <select id="playerColor">
                <option value="white" selected>White</option>
                <option value="black">Black</option>
              </select>
            </div>

            <div class="setting">
              <label>Engine:</label>
              <select id="engineType">
                <option value="stockfish-backend" selected>
                  Stockfish (Backend)
                </option>
                <option value="stockfish-js">
                  Stockfish.js (Local Browser)
                </option>
                <option value="lichess">Lichess API</option>
                <option value="chesscom">Chess.com API</option>
              </select>
            </div>

            <div class="setting">
              <label>
                Engine Strength:
                <span class="strength-value" id="strengthValue">20</span>
              </label>
              <input
                type="range"
                id="engineStrength"
                min="1"
                max="20"
                value="20"
                oninput="updateStrength(this.value)"
              />
              <small style="color: #718096">1 = Beginner, 20 = Master</small>
            </div>

            <div class="setting">
              <label>Analysis Depth:</label>
              <input
                type="range"
                id="analysisDepth"
                min="10"
                max="30"
                value="20"
              />
              <small style="color: #718096">Higher = Stronger but slower</small>
            </div>
          </div>

          <!-- Status -->
          <div class="panel">
            <h3>üìä Game Status</h3>
            <div class="status">
              <div class="status-turn" id="turnStatus">White to move</div>
              <div class="status-eval" id="evalStatus">Position: Equal</div>
            </div>
          </div>

          <!-- Top Moves -->
          <div class="panel">
            <h3>üéØ Top Moves</h3>
            <div class="loading" id="analysisLoading">
              <div class="spinner"></div>
              <div>Analyzing position...</div>
            </div>
            <div id="topMoves"></div>
          </div>

          <!-- Capture Moves -->
          <div class="panel">
            <h3>‚öîÔ∏è Capture Moves</h3>
            <div id="captureMoves">No captures available</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Scripts -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/stockfish.js@10.0.2/stockfish.js"></script>

    <script>
      // Configuration
      const API_URL = 'http://127.0.0.1:5000'
      const GAME_ID = 'web-game-' + Date.now()

      // Game state
      let game = new Chess()
      let board = null
      let playerColor = 'white'
      let currentEngine = 'stockfish-backend'
      let engineStrength = 20
      let isPlayerTurn = true
      let stockfishEngine = null
      let stockfishEngineGame = null // Separate Stockfish instance for playing
      let currentEvaluation = 0
      let lastMove = null // Track last move for highlighting
      let isWaitingForEngine = false

      // Initialize Stockfish.js for local evaluation
      function initStockfish() {
        if (typeof STOCKFISH === 'function') {
          // Evaluation engine
          stockfishEngine = STOCKFISH()

          stockfishEngine.onmessage = function (event) {
            const line = event.data || event

            // Parse evaluation from Stockfish output
            if (line.includes('score cp')) {
              const match = line.match(/score cp (-?\d+)/)
              if (match) {
                const centipawns = parseInt(match[1])
                updateEvaluationBar(centipawns / 100)
              }
            } else if (line.includes('score mate')) {
              const match = line.match(/score mate (-?\d+)/)
              if (match) {
                const mateIn = parseInt(match[1])
                updateEvaluationBar(mateIn > 0 ? 100 : -100, true, mateIn)
              }
            }
          }

          stockfishEngine.postMessage('uci')

          // Game playing engine (separate instance)
          stockfishEngineGame = STOCKFISH()

          stockfishEngineGame.onmessage = function (event) {
            const line = event.data || event

            // Extract best move
            if (line.includes('bestmove')) {
              const match = line.match(/bestmove ([a-h][1-8][a-h][1-8][qrbn]?)/)
              if (match && isWaitingForEngine) {
                isWaitingForEngine = false
                const moveUci = match[1]
                executeStockfishJSMove(moveUci)
              }
            }
          }

          stockfishEngineGame.postMessage('uci')
        }
      }

      // Get move from Stockfish.js
      function getStockfishJSMove() {
        if (!stockfishEngineGame) return

        isWaitingForEngine = true
        const skillLevel = Math.floor((engineStrength / 20) * 20) // 0-20

        stockfishEngineGame.postMessage(
          'setoption name Skill Level value ' + skillLevel
        )
        stockfishEngineGame.postMessage('position fen ' + game.fen())
        stockfishEngineGame.postMessage('go depth 15')
      }

      // Execute Stockfish.js move
      function executeStockfishJSMove(moveUci) {
        const from = moveUci.substring(0, 2)
        const to = moveUci.substring(2, 4)
        const promotion = moveUci.length > 4 ? moveUci.substring(4) : undefined

        const moveObj = {
          from: from,
          to: to,
        }

        if (promotion) {
          moveObj.promotion = promotion
        }

        const result = game.move(moveObj)

        if (result) {
          lastMove = { from: from, to: to }
          board.position(game.fen())
          highlightLastMove()
          addMoveToHistory(moveUci, 'AI')
          updateStatus()
          saveGameState()

          // Evaluate position after AI move
          setTimeout(() => evaluatePosition(), 100)
        }
      }

      // Highlight last move on board
      function highlightLastMove() {
        // Remove previous highlights
        $('#board .square-55d63').removeClass('highlight-last-move')

        if (lastMove) {
          // Add highlight to last move squares
          const fromSquare = '.square-' + lastMove.from
          const toSquare = '.square-' + lastMove.to

          $(fromSquare).addClass('highlight-last-move')
          $(toSquare).addClass('highlight-last-move')
        }
      }

      // Save game state to localStorage
      function saveGameState() {
        const gameState = {
          fen: game.fen(),
          pgn: game.pgn(),
          playerColor: playerColor,
          currentEngine: currentEngine,
          engineStrength: engineStrength,
          lastMove: lastMove,
          moveHistory: game.history({ verbose: true }),
        }

        localStorage.setItem('chessGameState', JSON.stringify(gameState))
      }

      // Load game state from localStorage
      function loadGameState() {
        const savedState = localStorage.getItem('chessGameState')

        if (savedState) {
          try {
            const gameState = JSON.parse(savedState)

            // Restore game
            game.load(gameState.fen)
            board.position(gameState.fen)

            // Restore settings
            playerColor = gameState.playerColor
            currentEngine = gameState.currentEngine
            engineStrength = gameState.engineStrength
            lastMove = gameState.lastMove

            // Update UI
            document.getElementById('playerColor').value = playerColor
            document.getElementById('engineType').value = currentEngine
            document.getElementById('engineStrength').value = engineStrength
            document.getElementById('strengthValue').textContent =
              engineStrength

            if (playerColor === 'black') {
              board.orientation('black')
            } else {
              board.orientation('white')
            }

            // Restore move history
            const historyContainer = document.getElementById('moveHistory')
            historyContainer.innerHTML = ''

            const moves = gameState.moveHistory
            for (let i = 0; i < moves.length; i++) {
              const player =
                moves[i].color === 'w'
                  ? playerColor === 'white'
                    ? 'You'
                    : 'AI'
                  : playerColor === 'white'
                  ? 'AI'
                  : 'You'
              addMoveToHistory(moves[i].from + moves[i].to, player)
            }

            highlightLastMove()
            updateStatus()
            evaluatePosition()

            return true
          } catch (error) {
            console.error('Error loading game state:', error)
            return false
          }
        }

        return false
      }

      // Clear saved game state
      function clearGameState() {
        localStorage.removeItem('chessGameState')
      }

      // Evaluate position with local Stockfish
      function evaluatePosition() {
        if (!stockfishEngine) return

        stockfishEngine.postMessage('position fen ' + game.fen())
        stockfishEngine.postMessage('go depth 15')
      }

      // Update evaluation bar
      function updateEvaluationBar(evaluation, isMate = false, mateIn = null) {
        currentEvaluation = evaluation

        const evalBarWhite = document.getElementById('evalBarWhite')
        const evalBarBlack = document.getElementById('evalBarBlack')
        const evalBarText = document.getElementById('evalBarText')

        // Clamp evaluation between -10 and +10 for display
        let displayEval = Math.max(-10, Math.min(10, evaluation))

        // Calculate percentage (50% = equal, 0% = black winning, 100% = white winning)
        // Formula: 50 + (eval * 5) to map -10..+10 to 0..100
        let whitePercentage = 50 + displayEval * 5
        whitePercentage = Math.max(0, Math.min(100, whitePercentage))

        const blackPercentage = 100 - whitePercentage

        // Update bar heights
        evalBarWhite.style.height = whitePercentage + '%'
        evalBarBlack.style.height = blackPercentage + '%'

        // Update text
        if (isMate && mateIn !== null) {
          evalBarText.textContent = `M${Math.abs(mateIn)}`
          evalBarText.style.color = mateIn > 0 ? '#2d3748' : '#f7fafc'
        } else {
          const evalText =
            evaluation >= 0
              ? `+${evaluation.toFixed(1)}`
              : evaluation.toFixed(1)
          evalBarText.textContent = evalText

          // Position text in the larger section
          if (whitePercentage > 60) {
            evalBarText.style.color = '#2d3748'
            evalBarText.style.top = 'auto'
            evalBarText.style.bottom = whitePercentage / 2 + '%'
            evalBarText.style.transform = 'translateY(50%)'
          } else if (blackPercentage > 60) {
            evalBarText.style.color = '#f7fafc'
            evalBarText.style.top = blackPercentage / 2 + '%'
            evalBarText.style.bottom = 'auto'
            evalBarText.style.transform = 'translateY(-50%)'
          } else {
            evalBarText.style.color = evaluation >= 0 ? '#2d3748' : '#f7fafc'
            evalBarText.style.top = '50%'
            evalBarText.style.bottom = 'auto'
            evalBarText.style.transform = 'translateY(-50%)'
          }
        }
      }

      // Initialize board
      function initBoard() {
        const config = {
          draggable: true,
          position: 'start',
          onDragStart: onDragStart,
          onDrop: onDrop,
          onSnapEnd: onSnapEnd,
        }

        board = Chessboard('board', config)
        $(window).resize(board.resize)
      }

      // Drag start handler
      function onDragStart(source, piece, position, orientation) {
        // Don't allow moves if game is over
        if (game.game_over()) return false

        // Only allow player to move their pieces
        if (
          (game.turn() === 'w' && piece.search(/^b/) !== -1) ||
          (game.turn() === 'b' && piece.search(/^w/) !== -1)
        ) {
          return false
        }

        // Only allow moves on player's turn
        if (
          (playerColor === 'white' && game.turn() !== 'w') ||
          (playerColor === 'black' && game.turn() !== 'b')
        ) {
          return false
        }
      }

      // Drop handler
      function onDrop(source, target) {
        // Check if move is legal
        const move = game.move({
          from: source,
          to: target,
          promotion: 'q', // Always promote to queen for simplicity
        })

        // Illegal move
        if (move === null) return 'snapback'

        // Save last move for highlighting
        lastMove = { from: source, to: target }
        highlightLastMove()

        // Evaluate position after player move
        setTimeout(() => evaluatePosition(), 100)

        // Save game state
        saveGameState()

        // Make move on server or use Stockfish.js
        if (currentEngine === 'stockfish-js') {
          addMoveToHistory(move.from + move.to, 'You')
          updateStatus()

          // Get AI move from Stockfish.js
          setTimeout(() => {
            getStockfishJSMove()
          }, 500)
        } else {
          makeMove(move.from + move.to)
        }
      }

      // Snap end handler
      function onSnapEnd() {
        board.position(game.fen())
      }

      // Update strength display
      function updateStrength(value) {
        engineStrength = parseInt(value)
        document.getElementById('strengthValue').textContent = value

        // Update on server
        fetch(`${API_URL}/set_engine_strength`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            game_id: GAME_ID,
            strength: engineStrength,
          }),
        })
      }

      // New game
      async function newGame() {
        playerColor = document.getElementById('playerColor').value
        currentEngine = document.getElementById('engineType').value
        engineStrength = parseInt(
          document.getElementById('engineStrength').value
        )

        game.reset()
        board.position('start')

        if (playerColor === 'black') {
          board.orientation('black')
        } else {
          board.orientation('white')
        }

        document.getElementById('moveHistory').innerHTML = ''
        document.getElementById('topMoves').innerHTML = ''
        document.getElementById('captureMoves').innerHTML =
          'No captures available'

        // Reset evaluation bar
        updateEvaluationBar(0)

        // Clear last move highlight
        lastMove = null
        highlightLastMove()

        // Clear saved state for new game
        clearGameState()

        // If using Stockfish.js, don't need backend
        if (currentEngine === 'stockfish-js') {
          // If player chose black, get AI move
          if (playerColor === 'black') {
            setTimeout(() => {
              getStockfishJSMove()
            }, 500)
          } else {
            setTimeout(() => evaluatePosition(), 100)
          }
          updateStatus()
          saveGameState()
          return
        }

        try {
          const response = await fetch(`${API_URL}/new_game`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              game_id: GAME_ID,
              color: playerColor,
              engine_strength: engineStrength,
            }),
          })

          const data = await response.json()

          if (data.ai_move) {
            setTimeout(() => {
              // Parse the AI move
              const from = data.ai_move.substring(0, 2)
              const to = data.ai_move.substring(2, 4)
              const promotion =
                data.ai_move.length > 4 ? data.ai_move.substring(4) : undefined

              const moveObj = {
                from: from,
                to: to,
              }

              if (promotion) {
                moveObj.promotion = promotion
              }

              const result = game.move(moveObj)

              if (result) {
                board.position(game.fen())
                addMoveToHistory(data.ai_move, 'AI')
                updateStatus()

                // Evaluate position after AI move
                setTimeout(() => evaluatePosition(), 100)

                if (data.analysis) {
                  displayAnalysis(data.analysis)
                }
              } else {
                console.error('Failed to make AI move:', data.ai_move)
                // Fallback: sync with server FEN
                game.load(data.fen)
                board.position(data.fen)
                setTimeout(() => evaluatePosition(), 100)
              }
            }, 500)
          }

          updateStatus()
        } catch (error) {
          console.error('Error creating new game:', error)
          alert('Error connecting to server. Make sure the backend is running!')
        }
      }

      // Make move
      async function makeMove(moveUci) {
        try {
          const response = await fetch(`${API_URL}/make_move`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              game_id: GAME_ID,
              move: moveUci,
            }),
          })

          const data = await response.json()

          if (data.success) {
            addMoveToHistory(data.player_move, 'You')
            updateStatus()

            if (data.ai_move) {
              setTimeout(() => {
                // Parse the AI move (format: e2e4 or e7e8q for promotions)
                const from = data.ai_move.substring(0, 2)
                const to = data.ai_move.substring(2, 4)
                const promotion =
                  data.ai_move.length > 4
                    ? data.ai_move.substring(4)
                    : undefined

                // Make the move in chess.js
                const moveObj = {
                  from: from,
                  to: to,
                }

                if (promotion) {
                  moveObj.promotion = promotion
                }

                const result = game.move(moveObj)

                if (result) {
                  // Update the board visually
                  board.position(game.fen())
                  addMoveToHistory(data.ai_move, 'AI')
                  updateStatus()

                  if (data.analysis) {
                    displayAnalysis(data.analysis)
                  }
                } else {
                  console.error('Failed to make AI move:', data.ai_move)
                  // Fallback: sync with server FEN
                  game.load(data.fen)
                  board.position(data.fen)
                }
              }, 500)
            }

            if (data.game_over) {
              setTimeout(() => {
                if (game.in_checkmate()) {
                  alert('Checkmate! Game over.')
                } else if (game.in_draw()) {
                  alert('Draw! Game over.')
                } else if (game.in_stalemate()) {
                  alert('Stalemate! Game over.')
                }
              }, 600)
            }
          }
        } catch (error) {
          console.error('Error making move:', error)
        }
      }

      // Analyze position
      async function analyzePosition() {
        document.getElementById('analysisLoading').classList.add('active')
        document.getElementById('topMoves').innerHTML = ''

        currentEngine = document.getElementById('engineType').value
        const depth = parseInt(document.getElementById('analysisDepth').value)

        // If using Stockfish.js, we can't get detailed analysis easily
        if (currentEngine === 'stockfish-js') {
          document.getElementById('analysisLoading').classList.remove('active')
          alert(
            'Detailed analysis not available with Stockfish.js engine. Please use backend engines for full analysis.'
          )
          return
        }

        try {
          const response = await fetch(`${API_URL}/analyze_position`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              game_id: GAME_ID,
              engine:
                currentEngine === 'stockfish-backend'
                  ? 'stockfish'
                  : currentEngine,
              top_moves: 5,
              depth: depth,
            }),
          })

          const data = await response.json()
          displayAnalysis(data)
        } catch (error) {
          console.error('Error analyzing position:', error)
        } finally {
          document.getElementById('analysisLoading').classList.remove('active')
        }
      }

      // Display analysis
      function displayAnalysis(analysis) {
        const container = document.getElementById('topMoves')
        container.innerHTML = ''

        if (!analysis.top_moves || analysis.top_moves.length === 0) {
          container.innerHTML = '<p>No analysis available</p>'
          return
        }

        // Update evaluation bar with position evaluation
        if (analysis.position_evaluation !== undefined) {
          updateEvaluationBar(analysis.position_evaluation / 100)
        }

        analysis.top_moves.forEach((move, index) => {
          const moveCard = document.createElement('div')
          moveCard.className =
            'move-card' +
            (index === 0 ? ' best' : '') +
            (move.is_capture ? ' capture' : '')

          const evalClass =
            move.evaluation > 50
              ? 'eval-positive'
              : move.evaluation < -50
              ? 'eval-negative'
              : 'eval-neutral'

          const evalText = move.is_mate
            ? `Mate in ${Math.abs(move.mate_in)}`
            : `${(move.evaluation / 100).toFixed(2)}`

          moveCard.innerHTML = `
                    <div class="move-header">
                        <span class="move-notation">${index + 1}. ${
            move.move
          }</span>
                        <span class="move-eval ${evalClass}">${evalText}</span>
                    </div>
                    <div class="move-details">
                        ${
                          move.is_mate
                            ? '<span class="badge badge-mate">MATE</span>'
                            : ''
                        }
                        ${
                          move.is_capture
                            ? '<span class="badge badge-capture">CAPTURE</span>'
                            : ''
                        }
                        ${move.piece} from ${move.from_square} to ${
            move.to_square
          }
                    </div>
                `

          container.appendChild(moveCard)
        })

        // Display captures
        if (analysis.capture_moves && analysis.capture_moves.length > 0) {
          displayCaptures(analysis.capture_moves)
        }

        // Update evaluation
        updateEvaluation(analysis.position_evaluation)
      }

      // Show captures only
      async function showCapturesOnly() {
        currentEngine = document.getElementById('engineType').value

        try {
          const response = await fetch(
            `${API_URL}/get_capture_moves?game_id=${GAME_ID}&engine=${currentEngine}`
          )

          const data = await response.json()

          if (data.capture_moves) {
            displayCaptures(data.capture_moves)
          }
        } catch (error) {
          console.error('Error getting captures:', error)
        }
      }

      // Display captures
      function displayCaptures(captures) {
        const container = document.getElementById('captureMoves')

        if (captures.length === 0) {
          container.innerHTML = 'No captures available'
          return
        }

        container.innerHTML = '<div class="captures-section"></div>'
        const section = container.querySelector('.captures-section')

        captures.forEach((move) => {
          const captureItem = document.createElement('div')
          captureItem.className = 'capture-item'

          const evalText = move.is_mate
            ? `M${Math.abs(move.mate_in)}`
            : `${(move.evaluation / 100).toFixed(1)}`

          captureItem.innerHTML = `
                    <strong>${move.move}</strong><br>
                    ${move.piece}: ${move.from_square}‚Üí${move.to_square}<br>
                    Eval: ${evalText}
                `

          section.appendChild(captureItem)
        })
      }

      // Compare engines
      async function compareEngines() {
        if (
          !confirm('This will analyze the position with all engines. Continue?')
        ) {
          return
        }

        document.getElementById('analysisLoading').classList.add('active')

        try {
          const response = await fetch(`${API_URL}/compare_engines`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ game_id: GAME_ID }),
          })

          const data = await response.json()

          let comparisonHTML = '<h4>Engine Comparison:</h4>'

          for (const [engine, analysis] of Object.entries(data)) {
            comparisonHTML += `
                        <div class="move-card">
                            <strong>${engine.toUpperCase()}</strong><br>
                            Best: ${analysis.best_move} 
                            (${(analysis.evaluation / 100).toFixed(2)})<br>
                            <small>Top 3: ${analysis.top_3
                              .map((m) => m.move)
                              .join(', ')}</small>
                        </div>
                    `
          }

          document.getElementById('topMoves').innerHTML = comparisonHTML
        } catch (error) {
          console.error('Error comparing engines:', error)
        } finally {
          document.getElementById('analysisLoading').classList.remove('active')
        }
      }

      // Add move to history
      function addMoveToHistory(move, player) {
        const history = document.getElementById('moveHistory')
        const moveItem = document.createElement('div')
        moveItem.className = 'move-item'

        const moveNumber = Math.floor(game.history().length / 2) + 1
        moveItem.textContent = `${moveNumber}. ${player}: ${move}`

        history.appendChild(moveItem)
        history.scrollTop = history.scrollHeight
      }

      // Update status
      function updateStatus() {
        const turn = game.turn() === 'w' ? 'White' : 'Black'
        const status = document.getElementById('turnStatus')

        if (game.in_checkmate()) {
          status.textContent =
            'Checkmate! ' + (turn === 'White' ? 'Black' : 'White') + ' wins!'
        } else if (game.in_draw()) {
          status.textContent = 'Draw!'
        } else if (game.in_stalemate()) {
          status.textContent = 'Stalemate!'
        } else {
          status.textContent = turn + ' to move'
          if (game.in_check()) {
            status.textContent += ' (in check)'
          }
        }
      }

      // Update evaluation
      function updateEvaluation(eval) {
        const evalStatus = document.getElementById('evalStatus')
        const evalValue = eval / 100

        if (Math.abs(evalValue) < 0.5) {
          evalStatus.textContent = 'Position: Equal'
        } else if (evalValue > 0) {
          evalStatus.textContent = `Position: White is better (+${evalValue.toFixed(
            2
          )})`
        } else {
          evalStatus.textContent = `Position: Black is better (${evalValue.toFixed(
            2
          )})`
        }
      }

      // Initialize on load
      window.onload = function () {
        initBoard()
        initStockfish()
        updateStatus()
        updateEvaluationBar(0) // Initialize bar at equal position

        // Try to load saved game state
        const loaded = loadGameState()

        // If no saved state, start a new game
        if (!loaded) {
          setTimeout(() => {
            newGame()
          }, 500)
        }
      }
    </script>
  </body>
</html>
